import java.util.jar.JarInputStream

plugins {
    id 'java'
    id 'jacoco'
    id 'com.jfrog.artifactory' version '4.28.2'
    id 'io.spring.dependency-management' version '1.0.6.RELEASE' apply false
    id 'org.sonarqube' version '3.5.0.2730'
    id 'de.thetaphi.forbiddenapis' version '3.0' apply false
    id 'com.diffplug.spotless' version '6.15.0'
}

allprojects {
    apply plugin: 'java'
    apply plugin: 'jacoco'
    apply plugin: 'io.spring.dependency-management'
    apply plugin: 'com.jfrog.artifactory'
    apply plugin: 'maven-publish'
    apply plugin: 'signing'

    gradle.projectsEvaluated {
        tasks.withType(JavaCompile).configureEach {
            if (project.hasProperty('warn')) {
                options.compilerArgs << "-Xlint:unchecked" << "-Xlint:deprecation"
            } else {
                options.compilerArgs << "-Xlint:-unchecked" << "-Xlint:-deprecation"
            }
        }
    }

    ext {
        buildNumber = System.getProperty("buildNumber")
        analyzerCommonsVersion = '2.7.0.1482'
        pluginApiVersion = '10.1.0.809'
        // slf4j is provided by SQ, SC or SL, should be aligned with sonar-plugin-api
        slf4jApiVersion = '1.7.30'
        sonarqubeVersion = '10.0.0.68432'
        orchestratorVersion = '3.42.0.312'
        sonarlintVersion = '9.0.0.74282'
        sonarLinksCi = 'https://cirrus-ci.com/github/SonarSource/slang'
        sonarLinksScm = 'https://github.com/SonarSource/slang'

        artifactsToPublish = '' +
          'org.sonarsource.slang:slang-api:jar,' +
          'org.sonarsource.slang:slang-plugin:jar,' +
          'org.sonarsource.slang:slang-antlr:jar,' +
          'org.sonarsource.slang:slang-testing:jar,' +
          'org.sonarsource.slang:slang-checks:jar,' +
          'org.sonarsource.slang:checkstyle-import:jar'

        artifactsToDownload = ''
    }

    // Replaces the version defined in sources, usually x.y-SNAPSHOT, by a version identifying the build.
    if (version.endsWith('-SNAPSHOT') && ext.buildNumber != null) {
        def versionSuffix = (version.toString().count('.') == 1 ? ".0.${ext.buildNumber}" : ".${ext.buildNumber}")
        version = version.replace('-SNAPSHOT', versionSuffix)
    }

    File extraProperties = new File(rootDir, 'private/extraProperties.gradle')
    if (extraProperties.exists()) {
        apply from: extraProperties
    }

    repositories {
        mavenLocal()
        def artifactoryBearerToken = System.getenv("ARTIFACTORY_PRIVATE_PASSWORD") ?: project.findProperty("artifactoryPassword")
        if (artifactoryBearerToken) {
            maven {
                url "https://repox.jfrog.io/repox/sonarsource"
                authentication {
                    header(HttpHeaderAuthentication)
                }
                credentials(HttpHeaderCredentials) {
                    name = "Authorization"
                    value = "Bearer $artifactoryBearerToken"
                }
            }
        }
        mavenCentral()
    }
}

subprojects {
    // do not publish to Artifactory by default
    artifactoryPublish.skip = true

    apply plugin: 'io.spring.dependency-management'
    apply plugin: 'com.diffplug.spotless'
    dependencyManagement {
        dependencies {
            dependency "org.sonarsource.api.plugin:sonar-plugin-api:${pluginApiVersion}"
            dependency "org.sonarsource.api.plugin:sonar-plugin-api-test-fixtures:${pluginApiVersion}"
            dependency "org.sonarsource.sonarqube:sonar-plugin-api-impl:${sonarqubeVersion}"
            dependency "org.slf4j:slf4j-api:${slf4jApiVersion}"
            dependency "ch.qos.logback:logback-classic:1.2.9"
            dependency "org.sonarsource.sonarqube:sonar-ws:${sonarqubeVersion}"
            dependency 'com.google.code.findbugs:jsr305:3.0.2'
            dependency 'com.eclipsesource.minimal-json:minimal-json:0.9.5'
            dependency "org.junit.jupiter:junit-jupiter-api:5.10.0"
            dependency "org.junit.jupiter:junit-jupiter-engine:5.10.0"
            dependency 'junit:junit:4.13.2'
            dependency 'org.mockito:mockito-core:5.5.0'
            dependency 'org.assertj:assertj-core:3.24.2'
            dependency 'io.github.classgraph:classgraph:4.8.162'
            dependency "org.sonarsource.analyzer-commons:sonar-analyzer-test-commons:${analyzerCommonsVersion}"
            dependency "org.sonarsource.analyzer-commons:sonar-analyzer-commons:${analyzerCommonsVersion}"
            dependency "org.sonarsource.analyzer-commons:sonar-xml-parsing:${analyzerCommonsVersion}"
            dependency "org.sonarsource.orchestrator:sonar-orchestrator:${orchestratorVersion}"
            dependency "org.sonarsource.sonarlint.core:sonarlint-core:${sonarlintVersion}"
            dependency "javax.annotation:javax.annotation-api:1.3.2"
        }
    }

    java {
        sourceCompatibility = JavaVersion.VERSION_11
        withSourcesJar()
        withJavadocJar()
    }
    jar {
        enabled=true
    }

    tasks.withType(JavaCompile) {
        options.encoding = "UTF-8"
        options.release = java.sourceCompatibility.majorVersion as int
    }

    jacoco {
        toolVersion = "0.8.7"
    }

    jacocoTestReport {
        reports {
            xml.required = true
            csv.required = false
            html.required = false
        }
    }

    // when subproject has Jacoco pLugin applied we want to generate XML report for coverage
    plugins.withType(JacocoPlugin) {
        tasks["test"].finalizedBy 'jacocoTestReport'
    }

    configurations {
        // include compileOnly dependencies during test
        testCompile.extendsFrom compileOnly
    }

    if (!project.path.startsWith(":its") && !project.path.startsWith(":private:its")) {
        test {
            useJUnitPlatform()
        }
    }

    test {
        testLogging {
            exceptionFormat 'full' // log the full stack trace (default is the 1st line of the stack trace)
            events "skipped", "failed" // verbose log for failed and skipped tests (by default the name of the tests are not logged)
        }
        def propKeys = System.properties.findAll {
            it.key.startsWith("orchestrator") || it.key.startsWith("sonar") || it.key == "buildNumber" || it.key == "slangVersion"
        }.collect { it.key }
        systemProperties = System.properties.subMap(propKeys)
        if (propKeys.contains("buildNumber") && !propKeys.contains("slangVersion")) {
            systemProperties["slangVersion"] = version
        }
    }

    // license updater
    spotless {
        java {
            targetExclude "**/src/test/resources/**", "**/build/**", "its/sources/**", "its/plugin/projects/**", "private/its/sources/**", "private/its/plugin/projects/**"

            if (getPath().startsWith(':private')) {
                licenseHeaderFile(rootProject.file("private/LICENSE")).updateYearWithLatest(true)
            } else {
                licenseHeaderFile(rootProject.file("LICENSE_HEADER")).updateYearWithLatest(true)
            }
        }
    }

    publishing {
        publications {
            mavenJava(MavenPublication) {
                pom {
                    name = projectTitle
                    description = project.description
                    url = 'http://www.sonarqube.org/'
                    organization {
                        name = 'SonarSource'
                        url = 'http://www.sonarsource.com'
                    }
                    licenses {
                        license {
                            name = 'GNU LGPL 3'
                            url = 'http://www.gnu.org/licenses/lgpl.txt'
                            distribution = 'repo'
                        }
                    }
                    scm {
                        url = 'https://github.com/SonarSource/slang'
                    }
                    developers {
                        developer {
                            id = 'sonarsource-team'
                            name = 'SonarSource Team'
                        }
                    }
                    // adding dependencies section for modules not using shadowJar (we didn't find a way to test if shadowJar is present)
                    if (["checkstyle-import",
                         "slang-antlr",
                         "slang-api",
                         "slang-checks",
                         "slang-plugin",
                         "slang-testing"]
                      .contains(project.name)) {
                        withXml {
                            def dependenciesNode = asNode().appendNode('dependencies')
                            // using runtimeClasspath and not compileClasspath because we don't want compileOnly dependencies (provided)
                            configurations.runtimeClasspath.allDependencies.each { dep ->
                                def dependencyNode = dependenciesNode.appendNode('dependency')
                                dependencyNode.appendNode('groupId', dep.group)
                                dependencyNode.appendNode('artifactId', dep.name)
                                if (dep.version) {
                                    dependencyNode.appendNode('version', dep.version)
                                }
                            }
                        }
                    }
                }
            }
        }
    }

    signing {
        def signingKeyId = findProperty("signingKeyId")
        def signingKey = findProperty("signingKey")
        def signingPassword = findProperty("signingPassword")
        useInMemoryPgpKeys(signingKeyId, signingKey, signingPassword)
        required {
            def branch = System.getenv()["CIRRUS_BRANCH"]
            return (branch == 'master' || branch ==~ 'branch-[\\d.]+') &&
                    gradle.taskGraph.hasTask(":artifactoryPublish")
        }
        sign publishing.publications
    }

    tasks.withType(Sign) {
        onlyIf {
            def branch = System.getenv()["CIRRUS_BRANCH"]
            return !artifactoryPublish.skip &&
                    (branch == 'master' || branch ==~ 'branch-[\\d.]+') &&
                    gradle.taskGraph.hasTask(":artifactoryPublish")
        }
    }
}

sonar {
    properties {
        property 'sonar.projectName', projectTitle
        property 'sonar.links.ci', "${sonarLinksCi}"
        property 'sonar.links.scm', "${sonarLinksScm}"
        property 'sonar.links.issue', 'https://jira.sonarsource.com/browse/SONARSLANG'
        property 'sonar.exclusions', '**/build/**/*'
    }
}

artifactory {
    clientConfig.setIncludeEnvVars(true)
    clientConfig.setEnvVarsExcludePatterns('*password*,*PASSWORD*,*secret*,*MAVEN_CMD_LINE_ARGS*,sun.java.command,*token*,*TOKEN*,*LOGIN*,*login*,*key*,*KEY*,*PASSPHRASE*,*signing*')
    contextUrl = System.getenv('ARTIFACTORY_URL')
    publish {
        repository {
            repoKey = System.getenv('ARTIFACTORY_DEPLOY_REPO')
            username = System.getenv('ARTIFACTORY_DEPLOY_USERNAME')
            password = System.getenv('ARTIFACTORY_DEPLOY_PASSWORD')
        }
        defaults {
            properties = [
                'build.name': 'slang-enterprise',
                'build.number': System.getenv('BUILD_NUMBER'),
                'pr.branch.target': System.getenv('PULL_REQUEST_BRANCH_TARGET'),
                'pr.number': System.getenv('PULL_REQUEST_NUMBER'),
                'vcs.branch': System.getenv('GIT_BRANCH'),
                'vcs.revision': System.getenv('GIT_COMMIT'),
                'version': version
            ]
            publications('mavenJava')
            publishPom = true
            publishIvy = false
        }
    }

    clientConfig.info.setBuildName('slang-enterprise')
    clientConfig.info.setBuildNumber(System.getenv('BUILD_NUMBER'))
    // Define the artifacts to be deployed to https://binaries.sonarsource.com on releases
    clientConfig.info.addEnvironmentProperty('ARTIFACTS_TO_PUBLISH', artifactsToPublish)
    clientConfig.info.addEnvironmentProperty('ARTIFACTS_TO_DOWNLOAD', artifactsToDownload)
    // The name of this variable is important because it's used by the delivery process when extracting version from Artifactory build info.
    clientConfig.info.addEnvironmentProperty('PROJECT_VERSION', "${version}")
}

void enforceJarSizeAndCheckContent(File file, long minSize, long maxSize) {
    long size = file.length()
    if (size < minSize)  {
        throw new GradleException("${file.path} size ($size) too small. Min is $minSize")
    } else if (size > maxSize) {
        throw new GradleException("${file.path} size ($size) too large. Max is $maxSize")
    }
    checkJarEntriesPathUniqueness file
}

// A jar should not contain 2 entries with the same path, furthermore Pack200 will fail to unpack it
void checkJarEntriesPathUniqueness(File file) {
    def allNames = new HashSet()
    def duplicatedNames = new HashSet()
    file.withInputStream { input ->
        new JarInputStream(input).withCloseable { jarInput ->
            for (def jarEntry = jarInput.nextJarEntry; jarEntry != null; jarEntry = jarInput.nextJarEntry) {
                if (!allNames.add(jarEntry.name)) {
                    duplicatedNames.add jarEntry.name
                }
            }
        }
    }
    if (!duplicatedNames.empty) {
        throw new GradleException("Duplicated entries in the jar: '${file.path}': ${duplicatedNames.join(', ')}")
    }
}
